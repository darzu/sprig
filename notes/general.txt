document.write("<h1>Hello, World!</h1>");

/*
<xml xmlns="http://www.w3.org/1999/xhtml">
    <variables></variables>
    <block type="event_with_action" x="72" y="83">
      <value name="someNumber">
        <shadow type="math_number">
          <field name="NUM">0</field>
        </shadow>
      </value>
    </block>
  </xml>

=>
*/

// RESEARCH:
// block node types:
//    label, hole, nested block, image, toggle, text entry, number entry, 
// dropdowns:
//    variables, enum values (math operators, sprite kinds, animation state) 
//    some are drag-out-able, some aren't
// needs to support custom field editors
// what to do about "+" and "-" ?
// mouth hole vs inline hole
//    if-else statements have multiple mouths
// IDEAS:
// - instead of function blocks, have a "create a block" editor

// REQUIREMENTS:
// - WordWrap
//  - can WordWrap within labels
// - Auto-format by default
// - "Holes" for clicking to add
// - custom field editors
// - custom block inner rendering
// - highlighting
//    - hover (white) and click (yellow)
// - context options: Duplicate, Add Comment, Delete Block, Help, Delete All
// - undo / redo
// NICE TO HAVE:
// - keyboard nav
// - equation builder
// 
// BLOCK ORGANIZATION:
// - Tabs? Collapsing code blocks?
// - columns, namable
//    - two finger swipe / horizontal scroll changes column

// BLOCK STRUCTURE:
// TYPES: control flow (can have mouth), statement, expression
// namespace Block {
//   type Shape = "statement" | "event"
//   type Label = string
//   type Constraints = "none" // type, shape, 
//   interface HoleDef {
//     constraints: Constraints
//   }
//   interface CustomNode {
//     // e.g. image
//   }
//   interface MouthHole {
//   }
//   type NodeDef = Label | HoleDef | CustomNode | MouthHole
//   interface BlockDef {
//     shape: Shape;
//     nodes: NodeDef[];
//   }
// }

// block definition vs block instance

// each block is an svg element?
// goals: drag and drop, canvas movement

// RENDERING:
// corner shapes: triangle, "circle", rounded-box
// stack divot
// mouth
// function "hat"

// need:
// function to draw corner types
// function to run horizontal
// function to run verticle
// function to draw hats and shoes
// 

// world.addEventListener(

function pCurve(p1: [number, number], p2: [number, number], smooth: number): string {
  const v2 = (xy: [number, number]): string => { return `${xy.x}, ${xy.y}` };
  let [x1, y1] = p1;
  let [x2, y2] = p2
  let yLen = (y2 - y1);
  let c1: [number, number] = [x1, y1 + yLen * smooth];
  let c2: [number, number] = [x2, y2 - yLen * smooth];
  let p = `M${v2(p1)} C${v2(c1)} ${v2(c2)} ${v2(p2)}`;
  return p;
}

// start block: 
/* 
m 0,4 // start
A 4,4 0 0,1 4,0 // top-left corner
H 156 // top
a 4,4 0 0,1 4,4 // top-right corner
v 40  // right 1
a 4,4 0 0,1 -4,4 // bottom-right corner
H 64 // inside top
// start notch (height of 6, corner radius of 4)
c -2,0 -3,1 -4,2 
l -4,4 
c -1,1 -2,2 -4,2 
h -12 
c -2,0 -3,-1 -4,-2 
l -4,-4 
c -1,-1 -2,-2 -4,-2 
// end notch
// inside top notch indent
h -8  
// inside top-left corner
a 4,4 0 0,0 -4,4 
// inside wall
v 16 
// inside bottom-left
a 4,4 0 0,0 4,4 
// inside bottom notch indent
h  8 
// start bottom notch
c 2,0 3,1 4,2 
l 4,4 
c 1,1 2,2 4,2 
h 12 
c 2,0 3,-1 4,-2 
l 4,-4 
c 1,-1 2,-2 4,-2 
// end bottom notch
// inside bottom
H 156 
// corner
a 4,4 0 0,1 4,4 
// right
v 24  
// corner
a 4,4 0 0,1 -4,4 
// bottom
H 4 
a 4,4 0 0,1 -4,-4 
z */
let blk2 = document.createElementNS("http://www.w3.org/2000/svg", "path")
// let path = pCurve([10, 10], [200, 200], 0.5);
let w = 100;
// let path = `M 100 100 q 0 -20, 20 -20 h 100 q 20 0, 20 20 v 100 q 0 20, -20 20 h -100 q -20 0, -20 -20 v -100`;
let refNotch = `c 10,0 15,5 20,10 
l 20,20 
c 5,5 10,10 20,10 
h 60 
c 10,0 15,-5 20,-10 
l 20,-20 
c 5,-5 10,-10 20,-10 `.replace("\n", " ");
refNotch = `c 2,0 3,1 4,2 
l 4,4 
c 1,1 2,2 4,2 
h 12 
c 2,0 3,-1 4,-2 
l 4,-4 
c 1,-1 2,-2 4,-2  `.replace("\n", " ")
let r2 = 4;
let path2 = `M 100 252 v -50 a ${r2} ${r2}, 0, 0 1, ${r2} -${r2} h 50 ${refNotch} h 50 v 50 Z`
blk2.setAttribute("d", path2);
// FYI: arcs suck


// toughest block: wall above, wall below, notch hat and show, triangle corners

// should pre-bake a bunch of paths for common block shapes

// WORD WRAPPING
// have a standard indent
let nodes: NodeSize[] = [
  [50, 50],
  [60, 60],
  // "\n",
  [100, 30],
  [
    [50, 50],
    // "\n",
    [30, 30],
  ],
  [20, 20]
];
// returns:
let positions: [
  // ...
]
// type BreakAfter = number;

// BLOCKS LIFECYCLE:
// Block defintion =>
// Block code tree => 
//    user code + links to block defs
// Block render tree =>
//    uses color pallets, determines shapes
//    sizes, newlines, chunked labels,
// Block SVG or canvas DOM
// BLOCK UPDATE LIFECYCLE:
//   update code tree
//   compute minimal update to render tree
//   re-render necessary parts
//      if canvas, re-render everything touched
//      if SVG, re-render affected blocks
// EXAMPLE:
//    sprite name "foo" => "foobar"
//    find related part of render tree, 
//    recompute leaf size,
//    perculate size change up
//    re-render relevant parts


function getSize(node: BlockNode): V2 {
  // TODO(dz):
  return [50, 50]
}

// outputs path
// needs to know: block children size, mouth children size, block children size

function renderBlock() {
  // render:
  // block, mouth, block, mouth, block
}

// type JSONValue = string | number | boolean | JSONObject | JSONArray;
// interface JSONObject {
//     [x: string]: JSONValue;
// }
// interface JSONArray extends Array<JSONValue> { }

// 
// process:
// render parent -> child, or child -> parent
// to render an obj:
//    get children total size, 
//    render out block,
//    return child locations
// get size -> simple work
// get child positions -> simplish work
// compute rendering assuming known child sizes -> simple ish
// lightning simple resizing ?
// provided renderers:
//    parent block, text, drop down, other

// parameters: min height, max width ?
// inputs: current indent
// pre-compute: word wrap
// inputs are: content WxH, mouth count WxH, content WxH
// compute: block width
// output: contents TL x,y

// how do holes work?
//    recieve a max width that's subtracted from the indent level
//    return a width & height used
// option A: compute everything without filling the hole, stretch to fit the hole contents
// option B: pre-compute everything, but be able to resize

// how to handle large expressions:
//    - like: boolean, math
//    - nesting: each layer adds width and height indentation
// example:
// if ( ( sprite vy (velocity y) > 0 and not is sprite hitting wall bottom) or sprite y < otherSprite top) then
// becomes:
// desirable breaking blocks: and, or, < >, break outermost first
/*
if (((sprite vy (velocity y) > 0)
     and not is sprite hitting wall bottom)
  or sprite y < otherSprite top) then
  */

// - first break in nodes indents
// - max width depends on whether or not it is indented (assume you're indented)

// WHY:
/*
- better understanding of blockly
- better understanding of SVG stuff
- proto wordwrap
- proto better blockly perf
- proto phone interface more quickly
- proto "hole" based block editting
- high motivation & inspiration
WHY NOT:
- ton of work
- sounds crazy
*/


// TODO: render element size with debug info;
// TODO: render correct corners and colors and notches

===

Needs:
    Word wrap
    first-class cursor navigation
    hole filling with context sensative filter

    type inference, communication and enforcement
    local variables
    higher order functions
    lambdas

    pattern matching

===

Languages:
  TS -> TS/w block assignments -> blocks -> nodes -> wrapped/nodes -> render

Hackathon goals:
  Show word wrapping
  Show multi-column
  Show cursor editting

===

consider tsconfig: 

            "es2015.promise",
            "es2015.collection",
            "es2015.iterable",
            "es2015.symbol.wellknown",
            "es2020.bigint"

======
Lots of agregated resources: http://www-cs-students.stanford.edu/~amitp/gameprog.html#hex


TO INVESTIGATE:
    quick.js (by ffmpeg guy)
        can bind native functions
    VM (from Michal)
    GLTF
    Sonic Retro Wiki

LEARNING SHADERS
https://lettier.github.io/3d-game-shaders-for-beginners/index.html
https://www.shadertoy.com
http://www.arteryengine.com/shadron/
https://learnopengl.com
https://www.realtimerendering.com
Borderlands texturing:
https://www.youtube.com/watch?v=YOQ0aspIn9c


// More Types!
type Vector<Length extends number> = TupleOf<number, Length>
type Matrix<Rows extends number, Columns extends number> = TupleOf<TupleOf<number, Columns>, Rows>

const v: Vector<2> = [1, 2]
const m: Matrix<2, 3> = [
  [1, 2, 3],
  [1, 2, 3],
]

Google Game Builder:
https://github.com/googlearchive/gamebuilder


HackMD.io
  collaborative markdown editting

Flash-like animations:
  https://www.rive.app


  Simplify each task, relentlessly make it easier at simpler
    3D modeling -> side,front view vertex dragging

Portals:
  https://www.youtube.com/watch?v=cWpFZbjtSQg
  https://www.youtube.com/watch?v=ivyseNMVt-4&t=3642s

Game idea generator:
  https://seblague.github.io/ideagenerator/

Growing plants over time:
  https://youtu.be/--GB9qyZJqg?t=394

Walking spider via programming
  https://youtu.be/--GB9qyZJqg?t=478

Orbital mechanics:
  https://www.youtube.com/watch?v=7axImc1sxa0

Fix float precision issues on big maps:
  https://youtu.be/7axImc1sxa0?t=662

Minecraft in C from scratch:
  https://www.youtube.com/watch?v=4O0_-1NaWnY

Minecraft w/ smooth voxels:
  https://www.youtube.com/watch?v=MazA1SlpwTY

Documentery on Stardew Valley:
  https://www.youtube.com/watch?v=4-k6j9g5Hzk

Redblob's pinboard:
  https://pinboard.in/u:amitp/t:graphics/

Indie game made in 18 months:
  https://www.youtube.com/watch?v=g5f7yixtQPc
  https://store.steampowered.com/app/555150/The_First_Tree/

Dark souls, the "ikea" of games:
  https://www.youtube.com/watch?v=vid5yZRKzs0

Books:
  http://www.realtimerendering.com/#rendpipe
  https://www.gameenginebook.com/

Game on steam w/ tutorial:
  https://store.steampowered.com/app/760330/BYTEPATH/
  https://github.com/a327ex/BYTEPATH
  https://github.com/a327ex/blog/issues/30
  https://love2d.org
  postmortem: https://github.com/a327ex/blog/issues/35
  1yr sales: https://github.com/a327ex/blog/issues/44
  second game: https://www.a327ex.com/posts/lessons_second_game/

Demoscene:
  https://github.com/psenough/teach_yourself_demoscene_in_14_days
  https://en.wikipedia.org/wiki/Demoscene

Brackeys:
  10 years of making games https://www.youtube.com/watch?v=T18X1HuawRc

Learning to code book:
  https://natureofcode.com/book/

Amazing interactive blog posts:
  https://ciechanow.ski/lights-and-shadows/

Inspiring voxel, marching cubes sphere planet:
  https://www.youtube.com/watch?v=vTMEdHcKgM4
  I want sprigland to be able to build something like this
    this implies that you'll be able to code at the vertex/indices buffer level
    and with compute shaders

A Slower Speed of Light
  http://gamelab.mit.edu/games/a-slower-speed-of-light/

Objectives / early result:
  Programming some basic shapes
  Sharing and playing multiplayer

Matrix math:
  http://web.cse.ohio-state.edu/~wang.3602/courses/cse5542-2013-spring/6-Transformation_II.pdf

  https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-837-computer-graphics-fall-2012/lecture-notes/MIT6_837F12_Lec03.pdf
    (new basis) = (old basis) * M
    (new basis) * M^-1 = (old basis)
    v = (old basis) * coord
    v = (new basis) * M^-1 * coord
    frame = origin and basis
    with 4-tuple:
      points have a "1" as last element
      vectors have a "0" as last element


Understanding quanternions / rotation:
  http://acko.net/blog/animate-your-way-to-glory-pt2/
  https://imadr.github.io/rotations-with-quaternions/
  https://marctenbosch.com/quaternions/
  https://rotations.berkeley.edu
  https://omar-shehata.medium.com/how-to-fix-gimbal-lock-in-n-dimensions-f2f7baec2b5e
  https://eater.net/quaternions

Voxel engine used by minecraft classic web:
  https://github.com/andyhall/noa/tree/develop

Roblox wannabe?
  https://www.coregames.com

Other game engines:
  http://www.rpginabox.com
    voxel, grid-based
  https://libgdx.com/showcase/
    java, opengl, mindustry, slay the spire,
  Minecraft voxel engine
    http://www.voxeljs.com
  http://superpowers-html5.com/index.en.html
    simplish 3D HTML engine

Good YouTube channels:
  https://www.youtube.com/watch?v=GWc7QppCPHM
    making a survival multiplayer game

Unreal Voxel system:
  https://www.youtube.com/channel/UCtJiCZyy95guZFCyBbnCs2Q

Bundler:
  https://parceljs.org
  https://esbuild.github.io/getting-started/

N-body simulation:
  "Barnes-Hut for gravity"

Data processing / query language?
  https://code.kx.com/q/

Rant about hosting:
  https://circleci.com/blog/its-the-future/

Third age of JS?
  https://www.swyx.io/js-third-age/

A project of ur own:
  http://paulgraham.com/own.html

Goal: the essential parts of every game can be done by one developer
  all the gameplay, all the assets
  AAA just throws people at more detail

For animations:
  Graphtoy tool, helps you visual curves

Triangle grids:
  https://www.boristhebrave.com/2021/05/23/triangle-grids/
  more on grids:
    https://www.redblobgames.com/grids/parts/

"NIMBY Rails"
  https://carloscarrasco.com/nimby-rails-retrospective/

Nvidia Graphics Codex:
  https://graphicscodex.courses.nvidia.com/app.html?page=rndint

Math notation to diagrams:
  https://www.cs.cmu.edu/~jssunshi/assets/pdf/penrose.pdf

"research debt":
  https://distill.pub/2017/research-debt/

Triangle solver:
  https://acegikmo.com/trianglesolver/

Lots of great visualizations of old math papers:
  https://twitter.com/gabrielpeyre

10 best visual explanations:
  https://twitter.com/AlanZucconi/status/1388482480253149184

New debugger viz:
  https://blog.replit.com/debuggest

About noise:
  https://varun.ca/noise/

How to make a vizualization like Redblob:
  https://twitter.com/redblobgames/status/1384561504565952515

Shortest path for car that can't go backwards:
  https://twitter.com/gabrielpeyre/status/1383284082944081928
  https://twitter.com/gabrielpeyre/status/1373152325888483328

Procedural gen workshop papers:
  http://www.pcgworkshop.com/database.php

Make arrow diagrams:
  https://q.uiver.app

Vector field explorer:
  https://anvaka.github.io/fieldplay
  https://twitter.com/redblobgames/status/1310716330278973440

Everybook should start with:
  https://twitter.com/round/status/1226640915390849024

"Learn how things work":
  https://jvns.ca/blog/learn-how-things-work/

Twitter search by user and date range:
  (from:redblobgames) until:2020-01-01 since:2015-01-01

Assign dwarves to jobs:
  https://twitter.com/gabrielpeyre/status/1372427547821101056

WebGL state diagrams:
  https://webglfundamentals.org/webgl/lessons/resources/webgl-state-diagram.html

"Octasphere":
  https://prideout.net/blog/octasphere/

Optical illusion of movement:
  https://jake.vision/blog/motion-illusions

Game devs advice:
  https://www.derekyu.com/makegames/archetypes.html

Rough sketches:
  https://roughjs.com

Comparing 2D Vector Field Visualization Methods: A User Study
  https://www.cs.unc.edu/~taylorr/Comp715/papers/laidlaw_vector_vis_user_study_01359732.pdf
  https://prideout.net/blog/streamlines/

Blogs to scan:
  https://prideout.net

non-square dithering:
  https://observablehq.com/@mattdzugan/dithering-on-non-square-pixels?collection=@mattdzugan/tilings

Redblob's project workflow:
  https://simblob.blogspot.com/2021/01/my-personal-information-workflow-part-1.html
  https://simblob.blogspot.com/2021/01/my-personal-information-workflow-part-2.html

Explanation of marching cubes:
  https://wordsandbuttons.online/interactive_explanation_of_marching_cubes_and_dual_contouring.html